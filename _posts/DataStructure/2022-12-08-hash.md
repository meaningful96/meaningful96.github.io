---
title: Chapter 6. Hash(해시)

categories: 
  - DataStructure
tags:
  - [Hash, Linear Structure]

toc: true
toc_sticky: true

date: 2022-12-08
last_modified_at: 2022-12-08 
---

## 1. Hash(해시)  
### 1) Hash Table(해시 테이블)  
* Hash Table은 <span style = "color:aqua">**매우 빠른 평균 insert, delete, search 연산 제공**</span>   
  - Ex) 딕셔너리(Dictionary)  
* 딕셔너리는 key와 value가 1:1로 대응된다.(Key : Value, 일대일대응)  
* 딕셔너리는 중괄호로 표기한다. {key:value}  

```python
D = {}
D['2019317'] = "신창수"

# 2019317 = key, 신창수 = value
```

### 2) Hash Table이 나온 이유?
* Data를 순차적으로 저장하는거 너무 비효율적이지 않아?  
* 순차적으로 저장하면 **원하는 위치(Index)에 정보를 삽입**하는데 너무 오랜 시간이 걸린다.!!
* 일반적인 딕셔너리의 삽입과 삭제, 탐색 연산은 $$O(N)$$의 시간 복잡도를 가진다.  

**순차적 자료구조의 문제점**
<p align = "center">
<img width="700" alt="image" src="https://user-images.githubusercontent.com/111734605/206415688-496fd21c-c693-4527-9d7e-2f50f70ee6a7.png">
</p>

### 3) How to Map?

<p align = "center">
<img width="500" alt="image" src="https://user-images.githubusercontent.com/111734605/206416335-b896a6f6-9780-4dcd-9ea9-bcca131084c9.png">
</p>

key값을 원하는 위치에 저장해야하는데, 그 과정을 도와주는 것이 바로 <span style = "color:aqua">**해시 함수(Hash function)**</span>이다.  

위의 그림을 예로들면, key값에 해당하는 것이 학번(2019311, 2018513)이고, value가 이름(신창수, 홍길동)이다. 그림에서보면 첫번째 데이터는 1번 인덱스에 저장되었고,
두 번째 데이터는 3번 인덱스에 저장된 걸 볼 수 있다. 위의 그림의 해쉬 함수는 key값을 10으로 나눈 나머지에 해당한다.

* Ex) 
    - 신창수:key = 2019311
      - 2019311 % 10 = 1(10으로 나눈 나머지)
    - 홍길동:key = 2018513
      - 2018513 % 10 = 3(10으로 나눈 나머지)

* <span style = "color:aqua">**1st Point)**</span>
  - Hash function: f(key) = Index Number
* <span style = "color:aqua">**2nd Point)**</span>
  - 이미 다른 Item이 저장되어 있을 때 **충돌(Collision)**이 발생한다.
  - 어디어 어떤 Rule에 의해 저장해? : Collision Resolution Method
* <span style = "color:aqua">**3rd Point)**</span>
  - Hash
    1. Table: List
    2. Hash Function
    3. Collision Resolution Method

### 4) 해시 함수(Hash Fucntion)
해시 함수는 결국, 가지고 있는 데이터를 어떠한 인덱스에 넣어줄 지를 결정해주는 하나의 수단이다. 하지만 이 해시 함수를 잘 정하는 것이 중요하다. 왜냐하면 다른 데이터이지만, 해시 함수
를 통과한 후의 결과가 같으면, 같은 인덱스에 mapping이 일어나는 **충돌**이 일어날 수 있기 때문이다.

<p align = "center">
<img width="700" alt="image" src="https://user-images.githubusercontent.com/111734605/206420030-a0a092be-498e-4eff-91d9-5e8774438195.png">
</p>

데이터와 해시 함수, 해시 테이블의 관계는 위와 같다.

#### Ex1) 나머지 연산 해시 함수

<p align = "center">
<img width="700" alt="image" src="https://user-images.githubusercontent.com/111734605/206420487-00eb08b7-8cc9-4462-b1f1-d0de0c2feb0a.png">
</p>

- $$f(k) = k % m$$
- $$f(k) = (k % p) % m$$

#### Ex2) Perfect Hash function

<p align = "center">
<img width="460" alt="image" src="https://user-images.githubusercontent.com/111734605/206423357-e0200cdf-e4a7-4b82-b2ad-5c94d35f4f98.png">
</p>

#### Ex3) Universial Hash function

<p align = "center">
<img width="460" alt="image" src="https://user-images.githubusercontent.com/111734605/206426496-da7f6cf3-a339-40d8-9658-04d044099d07.png">
</p>

#### Ex4) 다양한 해시 함수 예시

<p align = "center">
<img width="600" alt="image" src="https://user-images.githubusercontent.com/111734605/206430205-4e2ba98a-6b7f-4109-909a-3bd318cb13ca.png">
</p>

*  좋은 Hash Table의 조건!!  
  1. <span style = "color:aqua">Less Collision</span>  
  2. <span style = "color:aqua">Fast Computation(But 둘은 Trade off)</span>  

## 2. 충돌 회피방법(Collision Resolution Method)   
### 1) Open Addressing     
* 주위에 빈칸을 찾아서 저장한다.    
* 방법)  
  - Linear Probing  
  - Quadratic Probing  
  - Double Hashing Probing
  - Chainging  

#### (1) Linear Probing    
- 충돌(collision)이 일어나면 바로 밑, 거기도 차있으면 그 밑, ... 해서 채움  
- $$ k → k+1 → k+2 → k+3 → ... $$  

<p align = "center">
<img width="700" alt="image" src="https://user-images.githubusercontent.com/111734605/206432140-826e8463-07b9-4d3c-be70-ed3e1353d6b9.png">
</p>

#### (2) Quadratic Probing    
- Linear Probing은 한 칸씩 이동하며 빈공간을 찾아 채워 넣는다.  
- 반면 Quadratic Probing은 이름에서 알 수 있듯, 제곱항을 더해주는 것이다.  
- $$k → k+1^2 → k+2^2 → k+3^3 → ...$$  
- 제곱항이 더해지므로, remove함수가 복잡해진다.  

#### (3) Double Hashing Probing    
- Hash 두 개를 연결(Hash_1 + Hash_2)  
- Hash_1의 해시 함수는 f(key)이고, Hash_2의 해시 함수는 g(key)이다.  
- $$f(key) + g(key) → f(key) + 2g(key) → f(key) + 3g(key) → ...$$  

#### (4) Chainging  
- 하나의 Slot에 여러 개의 Item을 저장하면 되잖아!!
- 해시테이블의 각 슬롯이 한방향 연결리스트로 구현되어 있다.
- 이에따라 충돌 key의 평균 개수는 각 슬롯별 연결리스트의 평균 길이와 같다.

<p align = "center">
<img width="600" alt="image" src="https://user-images.githubusercontent.com/111734605/206434478-bf70d92c-6895-44b8-becc-ebae4d467abb.png">
</p>

- **하나의 slot에 여러 개의 아이템을 저장**하는 방식.
- 각 슬롯에 한방향 연결리스트를 만든다.(Doubly Linked List로도 구현 가능)
- **set** 함수가 항상 **$$O(1)$$** 시간 보장.
- **search, remove** 함수는 **각 슬롯내의 노드 갯수만큼 $$O(n)$$**간 (충돌 key의 평균 갯수)
- C-universal 해시 함수를 사용하면 set, search, remove가 **$$O(1)$$**
- C-universal 해시 함수를 사용하면 $$\frac{c}{n}$$
- <span style = "color:aqua">C-universal Hash function을 쓰고 충분한 Load Factor를 확보하면 상수시간 내에 set, search, remove 연산을 수행 가능!!!</span>
