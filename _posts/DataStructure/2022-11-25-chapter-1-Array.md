---
title: Chapter 1. Array & List

categories:
  - DataStructure
tags:
  - [DS,DataStructure,Array, List]

toc: true
toc_sticky: true

date: 2022-11-25
last_modified_at: 2022-11-25 
---

## 1. Array
### 1) Array(배열)이란?
배열이란 같은 성질을 갖는 항목들의 집합이다. 같은 특성을 갖는 원소들이 <span style = "color:aqua">**순서대로**</span> 구성된 선형 자료 구조이며, 메모리 상에 연속적으로
데이터가 저장된 순차 리스트에 해당한다. 순차적으로 저장된 데이터를 참조하는 데에는 <span style = "color:aqua">**Index**</span>가 사용된다.

Index	0	1	2	3	4	5	6	7
data	10	4	2	9	7	6	2	1
![image](https://user-images.githubusercontent.com/111734605/203910344-cf37af79-f47e-463d-973c-a981d238aa59.png)


### 2) Array의 특징
- 고정된 크기를 갖는다.(데이터의 수가 정해져 있다.) 즉, 사용할 수 있는 메모리의 크기가 정해져 있다.
  - Ex) Array.size = 10, 내부 데이터가 5개만 있더라도 실제 배열의 크기는 10 => 메모리 낭비 가능성 존재
- 논리적 저장 순서 = 물리적 저장 순서
- 추가적으로 소모되는 메모리 양(오버헤드)이 거의 없음. (Why? 데이터의 양에 맞게 크기를 정해놓고 사용하기 때문)
- 삽입 & 삭제의 경우 O(N)
- 원소에 접근 O(1)
- 기억 장소를 미리 확보해야 한다.
- 높은 Cache Hit Rate를 보여준다.
  - Cache Hit Rate란 원하는 정보가 캐시 메모리에 기억되어 있을 때를 적중(Hit) 아닐 때를 실패했다고 한다. 적중률 = 적중 횟수/총 접근 
  - Array는 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성인 공간 지역성(Spacial Locality)가 좋아 Cache Hit Rate가 높은 것이다.

### 3) Array의 연산

#### (1) 요소 확인 & 요소 변경  
**확인**  
확인(Search)는 특정 인덱스에 있는 요소를 확인하는 것이다. 즉, 특정 인덱스만 있으면 바로 확인 가능하기에 O(1)의 Time complexity를 가진다.

|Index|0|1|2|3|4|5|6|7|
|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|
|Data|10|4|2|9|7|6|2|1|

**변경**  
변경 역시 특정 인덱스의 값 만을 바꾸는 것이다. 정확히 말하면 특정 인덱스에 할당된 주소를 바꾸는 것이다.

- 확인 : O(1)
- 변경 : O(1)

#### (2) 원소 삽입 및 삭제  
**삭제**  
pop(3)    # 3번 index의 값을 삭제한다.  
여기서 중요한 것은 3번 인덱스가 삭제되었으면 그 다음에 있던 인덱스들을 한칸식 앞으로 밀린다는 것이다.

<span style = "color: aqua">Before</span>  
|Index|0|1|2|3|4|5|6|7|
|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|
|Data|10|4|2|9|7|6|2|1|


<span style = "color: aqua">After pop(3)</span>  
|Index|0|1|2|3|4|5|6|7|
|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|
|Data|10|4|2|7|6|2|1|None|

어떠한 원소를 삭제할 때 평균적으로 $\frac{N}{2}$ 만큼 떙겨야 하므로 삭제의 시간 복잡도는 <span style = "color: aqua">**O(N)**</span>이다.  

**삽입**  
크기가 10인 배열에 7개의 데이터가 들어 있다고 하자. 인덱스 3위치에 데이터 19를 추가한다면, 인덱스 3 우측에 있는 데이터들을 한 칸씩 우측으로 밀리게 된다.

<span style = "color: aqua">Before</span>  
|Index|0|1|2|3|4|5|6|7|8|9|
|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|
|Data|10|2|4|3|1|8|9|None|None|None|

<span style = "color: aqua">After insert(3,19)</span>  
|Index|0|1|2|<span style = "color: aqua">**3**</span> |4|5|6|7|8|9|10|
|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|
|Data|10|2|4|19|<span style = "color:aqua">19</span>|1|8|9|None|None|

역시 마찬가지로, 평균적으로 $\frac{N}{2}$ 만큼 우측으로 밀어야 하므로 시간 복잡도는 <span style = "color: aqua">**O(N)**</span>이다.

- 삽입 : O(N)
- 삭제 : O(N)
