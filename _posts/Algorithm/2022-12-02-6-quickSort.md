---
title: Chapter 1.6 Quick Sort(퀵 정렬)

categories: 
  - Algorithm
tags:
  - [Algorithm, Sort, Quick Sort]

toc: true
toc_sticky: true

date: 2022-12-02
last_modified_at: 2022-12-02 
---

## 1. 퀵정렬(Quick Sort)
### 1) 퀵정렬(Quick Sort) 알고리즘의 개념 요약
- 찰스 앤터니 리처드 호어(Charles Antony Richard Hoare)가 개발한 정렬 알고리즘
- 퀵 정렬은 **불안정 정렬**에 속하며, <span style="color:aqua">다른 원소와의 비교만으로 정렬을 수행하는 **비교 정렬**</span>에 속한다.
- **분할 정복 알고리즘**의 하나로, 평균적으로 <span style = "color:aqua">매우 빠른 수행 속도</span>를 자랑
  - 병합 정렬과 달리 퀵 정렬은 리스트를 **비균등**하게 분할한다.

- 분할 정복(Divide and Conquer)방법
  - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
 
* 과정 설명
  1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 <span style="color:aqua">**피벗(pivot)**</span> 이라고 한다.
  2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
  3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
      * 분할된 부분 리스트에 대하여 **순환 호출** 을 이용하여 정렬을 반복한다.
      * 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
     * 리스트의 크기가 0이나 1이 될 때까지 반복한다.  
 
<p align="center">
<img width="600" alt="1" src="https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort-concepts.png">
</p>  

### 2) 퀵 정렬 알고리즘의 예제
* 배열에 5,3,8,4,9,1,6,2,7이 저장되어 있다고 가정하고 자료를 오름차순으로 정렬해 보자
* 퀵 정렬에서 피벗을 기준으로 두 개의 리스트로 나누는 과정

<p align="center">
<img width="600" alt="1" src="https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort2.png">
</p> 

* 피벗 값을 입력 리스트의 첫 번째 데이터로 하자. (다른 임의의 값이어도 상관없다.)
* 2개의 인덱스 변수(low, high)를 이용해서 리스트를 두 개의 부분 리스트로 나눈다.
* 1회전: 피벗이 5인 경우,
  1. low는 왼쪽에서 오른쪽으로 탐색해가다가 피벗보다 큰 데이터(8)을 찾으면 멈춘다.
  2. high는 오른쪽에서 왼쪽으로 탐색해가다가 피벗보다 작은 데이터(2)를 찾으면 멈춘다.
  3. low와 high가 가리키는 두 데이터를 서로 교환한다.
  4. 이 탐색-교환 과정은 low와 high가 엇갈릴 때까지 반복한다.
* 2회전: 피벗(1회전의 왼쪽 부분리스트의 첫 번째 데이터)이 1인 경우,
  - 위와 동일한 방법으로 반복한다.
* 3회전: 피벗(1회전의 오른쪽 부분리스트의 첫 번째 데이터)이 9인 경우,
  - 위와 동일한 방법으로 반복한다


