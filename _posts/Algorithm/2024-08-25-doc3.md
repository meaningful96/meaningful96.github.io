---
title: "[알고리즘]Recursion(재귀) 알고리즘 - (2) Hanoi, Magic Index"

categories: 
  - Algorithm

toc: true
toc_sticky: true

date: 2024-08-25
last_modified_at: 2024-08-25 
---

# Recursion(재귀)
## 문제 6: Hanoi Tower
<div style="display: flex; justify-content: center; align-items: center;">
  <video width="800" controls>
    <source src="https://github.com/user-attachments/assets/467e630a-c96f-4770-8d26-2b794f3dae7b" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</div>

이 동영상의 출저는 [Program for Tower of Hanoi Algorithm](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/)이다. $$N=3$$일 때의 하노이 탑 문제를 보여준다.


- **Base Case (기본 사례)**
  - 하노이 탑 문제에서 기본 사례는 이동할 디스크가 없는 경우이다. $$n < 1$$일 때, 함수는 0을 반환한다.
  - 이는 더 이상 이동할 디스크가 없음을 의미하며, 재귀 호출이 종료되는 조건이다.

- **Inductive Case (유도 단계)**
  - 하노이 탑 문제에서 $$n$$개의 디스크를 다른 기둥으로 옮기는 문제는 세 단계로 나눌 수 있다.
    -  총 $$n-1$$개의 디스크를 첫 번째 기둥에서 두 번째 기둥으로 옮긴다.
    -  가장 큰 디스크(마지막 디스크)를 첫 번째 기둥에서 세 번째 기둥으로 옮긴다.
    -  두 번째 기둥에 있던 $$n-1$$개의 디스크를 세 번째 기둥으로 옮긴다.
  - 함수는 이러한 단계들을 재귀적으로 호출하여 문제를 해결한다.

```python
def hanoi(n: int, a=1, b=2, c=3) -> int:
    if n < 1:
        return 0
    # n-1개의 디스크를 A에서 B로 이동
    numAToB = hanoi(n - 1, a, c, b)
    print("Move disk from {} to {}".format(a, c))
    # n-1개의 디스크를 B에서 C로 이동
    numBToC = hanoi(n - 1, b, a, c)
    return numAToB + 1 + numBToC

def test(n: int) -> int:
    print("Hanoi({})".format(n))
    return hanoi(n)

if __name__ == "__main__":
    # 테스트 실행: 디스크 3개
    test(3)
```
