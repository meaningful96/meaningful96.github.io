---
title: "[알고리즘 정복하기!] Greedy Algorithm(탐욕 알고리즘)"

categories:
  - Algorithm
tags:
  - [Algorithm, Greedy]

toc: true
toc_sticky: true

date: 2023-09-02
last_modified_at: 2023-09-02 
---

# 1. Greedy Algorithm
## 1) Definition
<span style = "color:gold"><b>Greedy</b></span>는 '**탐욕스러운, 욕심 많은**'이란 뜻이다. 탐욕 알고리즘은 말 그대로 <u>선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫒아 최종적인 해답에 도달</u>하는 알고리즘이다. 탐욕 알고리즘을 이해하기 위해서는 두 가지 용어를 이해해야 한다.

- <b>알고리즘 오버헤드(Algorithm Overhead)</b>
  - 어떤 문제에 최적의 해결책을 찾기 위해서는 시간이 소요된다. 알고리즘 오버헤드는 간단하게 문제를 해결하는데 걸리는 시간이며, 복잡한 문제일수록 최적의 해결책을 찾는 데 걸리는 시간이 길어진다.

- <b>최적해와의 차이(Delta from Optimal)</b>
  - 최적화 문제에는 최적의 해결책이 존재한다. 이를 최적해(optimal solution)이라고 한다. 많은 알고리즘은 보통 반복 과정을 통해 해결책을 점차 업데이트하는 방식으로 취한다.

Greedy 알고리즘을 다시 한 번 정리하면, 최적해를 구하는 근사적인 방법이다. 여러 경우 중 최적의 하나인 option만을 고집하며 반복적으로 선택해 나가 최종적인 해답에 도달한다. 순간마다 하는 선택은 그 순간에 대해 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적(전역적)인 해답을 만들었다고 해서, 그것이 최적이라는 보장은 없다. 
하지만, Greedy 알고리즘을 적용할 수 있는 문제들은 지역적으로 최적이면서 전역적으로 최적인 문제들이다.

 <span style = "font-size:110%"><span style = "color:gold">➜ Greedy Algorithm: 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.</span></span> 

## 2) 문제 해결 방법
1. **선택 절차(Selection Procedure)**: 현재 상태에서의 최적의 해답을 선택
2. **적절성 검사(Feasibility Check)**: 선택된 해가 문제의 조건을 만족하는지 검사
3. **해답 검사(Solution Check)**: 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복

## 3) Greedy 알고리즘의 성립 조건 2가지
앞서 말했듯 Greedy 문제로 정의하려면 두 가지 성립 조건을 필요로한다.
- **탐욕적 선택 속성(Greedy Choice Property)** : 앞의 선택이 이후의 선택에 영향을 주지 않는다.
- **최적 부분 구조(Optimal Substructure)** : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다.

> 탐욕 알고리즘은 항상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적에 근사한 값을 빠르게 도출할 수 있는 장점이 있다. 이 장점으로 인해 탐욕 알고리즘은 근사 알고리즘으로 사용할 수 있다.

> 탐욕 알고리즘을 적용해도 언제나 최적해를 구할 수 있는 문제(매트로이드)가 있고, 이러한 문제에 탐욕 알고리즘을 사용해서 빠른 계산 속도로 답을 구할 수 있다. 그래서 실용적으로 사용할 수 있다.

<br/>
<br/>

# Greedy Algorithm Example
## 1) Example 1 - 거스름돈
Q. 당신은 편의점의 점원이다. 카운터에서 거스름돈으로 사용할 수 있는 동전은 500원, 100원, 50원, 10원이며 각각의 개수는 무한하다 가정한다. 손님에게 거슬러 줘야 할 돈이 1260원 일 때 거슬러 줘야 할 동전의 최소 개수는?  
(단, 거슬러 줘야 할 돈은 항상 10의 배수이다.)

➜ Key Point: 가장 큰 화폐 단위부터 돈을 거슬러 준다.

```python
# 거스름돈 문제
# 500원, 100원, 50원, 10원
# N = 1260

N = 1260
cnt = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500,100,50,10]

for coin in coin_types:
    cnt += N//coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    N = N % coin

print(cnt)
```

- Time Complexity: O(K)
- idea review
  - 10원짜리로만 모두 거슬러 주면? ➝ X ➝ 50원짜리로만? ➝ X ➝ ... ➝ 가장 큰 500원짜리부터 거슬러서 가장 작은 10원짜리까지 차례대로 거슬러 준다면?
  - 결국 거스름돈 문제에서는 큰 단위가 항상 작은 단위의 배수 형태이므로 최적해를 항상 보장받을 수 있다!!
     
<span style="font-size:110%"><b>그리디 알고리즘의 정당성</b></span>  
그리디 알고리즘을 모든 알고리즘에 적용할 수는 없다. 대부분의 문제는 그리디 알고리즘을 적용했을 때 '최적해'에 도달할 가능성이 낮다. 반면, 거스름돈 문제처럼 탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다. 그리디 알고리즘을 수행한 후 그 해법이 정당한지 반드시 검토해야 한다.

위의 문제에서 그리디 알고리즘이 적법한 알고리즘인 이유는 <u>가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문</u>이다. 대부분의 그리디 알고리즘 문제에서는 <span style="color:gold"><b>문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출</b></span>할 수 있다.

## 2) Example 2 - 큰 수의 법칙
- 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.
  - 예를 들어 순서대로 2,4,5,4,6 인 배열이 있을 때 M = 8이고, K = 3이라고 가정하자
  - 이 경우 특정 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 버칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 = 46이 된다.
  - 3,4,3,4,3, M=7, K=2일 때 4 + 4 + 4 + 4 + 4 + 4 + 4 = 28 (2번째 4와 4번째 4를 번갈아 가며 2번씩 더함.)

- 입력 조건
  - 첫째 줄에 N(2 $$\leq$$ N $$\leq$$ 1,000), M(1 $$\leq$$ M $$\leq$$ 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
  - 둘째 줄에 N갸의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10,000 이하의 수로 주어진다.
  - 입력으로 주어지는 K는 항상 M보다 작거나 같다.
  - 첫째 줄에 큰 수의 법칙에 따라 더해진 답을 출력한다.    
 
```python

```
