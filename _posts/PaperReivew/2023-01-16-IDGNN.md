---
title: Identity-Aware Graph Neural Network

categories: 
  - PaperReview
  
tags:
  - [GNN,Graph]
  
toc: true
toc_sticky: true

date: 2023-01-16
last_modified_at: 2023-01-16
---
## 1. Problem Set  
### 1) Limitation of Existing GNN Architecture  
- Fail to capture the position(location) of the node within the broader context of the graph structure  
  - 즉, Graph에서 노드들의 위치를 구분하지 못한다. 다시 말해 노드들의 위치 정보가 부족하다.

### 2) Limitation of One-hot Encoding
- Models trained with one-hot encodings cannot generalize to unseen graphs, and arbitrarily deep GNNs still cannot distinguish structurally isomorphic nodes
  - One-hot encoding으로 모델을 학습시키면 Unseen Grpah에 대해서 일반화하지 못한다. 즉, Graph의 Isomorphic(Symmetric) node를 구별하지 못한다.

### 3) GNNs also Can't perfectly perform in Structure-Aware  
기존의 GNN 기반 모델들은 Structure-aware 이다. 하지만, 그렇다고해서 Structure-aware task에 해당하는 모든 문제를 정확하게 해결하지 못한다.
- Three levels of failure cases
  1. Node Level
  2. Edge Level
  3. Graph Level

<span style = "font-size: 120%">1. Node Level</span>  

<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212622710-b250c439-ef5b-4547-b0db-6a24df2854f1.png">
</p>

먼저 Node Level에서 GNN의 문제점을 살펴보면, 서로 다른 Input graph이 GNN을 통과했음에도 같은 모양의 Embdedding 결과를 보여준다. 즉, GNN의 Computational Graph에서
$$v_1$$과 $$v_2$$를 중심으로 하는 Tree(computational graph)는 <span style = "color:aqua">Isomorphic하기 때문에 GNN에서는 두 노드를 **같은 노드로 인식**</span>하게 된다.
임베딩 결과가 구조적으로 동일하기 때문에 $$v_1$$과 $$v_2$$를 다른 Class로 분류하지 못한다.(위의 Task는 Node Classification)

참고로 Computational graph는 다음과 같은 과정으로 만들어진다.

<p align="center">
<img width="700%" alt="1" src="https://user-images.githubusercontent.com/111734605/212675901-98d9e687-796b-4284-86b6-5777e6e1fe50.png">
</p>

<span style = "font-size: 120%">2. Edge Level</span>


<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212623757-a9a80797-81a2-4314-bd09-3285f954f7f9.png">
</p>

Edge Level에서 GNN의 문제점을 바라보면 위의 task는 Link prediction인데, 위의 Input을 보면, $$v_0$$에서 $$v_1$$또는 $$v_2$$로 Edge를 연결할 지를 정하기 위해
GNN을 이용하면 두 노드 모두 기준점 $$v_0$$에서 1-hop씩 direct하게 연결되기에 결국 임베딩 결과가 같은, Computational graph가 동일하게 나온다. 결론적으로 Link
Prediction task를 해결하지 못한다.

<span style = "font-size: 120%">3. Graph Level</span>

<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212625482-1fe22112-7f54-4293-be8c-7bb4383e15d9.png">
</p>

Graph-Level 수준에서 풀고자 하는 task는 Graph classification으로 Node level에서와 마찬가지로 서로 다른 Input임에도 임베딩 결과가 같아 서로 다른 Class로 구분하지 못한다.

## 2. Related Work
[GNN]()
[GCN]()
[GAN]()
[GIN]()
[GraphSAGE]()
[P-GNN](https://meaningful96.github.io/paperreview/PGNN/)

- Expressive neural networks beyond 1-WL test
- Graph Neural Networks with inductive coloring
- GNNs with anisotropic message passing

## 3. Method
### 1) Idea: Inductive Node Coloring

<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212626502-bbb3973d-90c9-4621-b980-c0e31d6b69cd.png">
</p>

Identity-aware GNN의 Key idea는 바로 "<span style = "color:gold">Coloring</span>"이다. 특정 노드에 색깔을 입히는 것이다. 여기서 특정 노드에 색깔을 입힌다는 것은
다시 말하면 특정 노드를 구별할 수 있게 Attribute를 추가한다는 것이다.

이렇게 하면 위의 그림에서처럼 $$v_1$$에 대한 임베딩을 할 때 $$v_1$$을 계속해서 추적할 수 있다. 이 때 **"Coloring"을 Inductive**라고 한다. 이 Inductive는 node 순서나
Identity에 대해서 변하지 않는다.

Coloring으로 인해서 Subtree를 비교하면, <span style = "color:aqua">비교할 수 있는 기준점이 생겨 **같은 Computational graph임에도(= 같은 Structure) Class 구분이 가능**</span>하다. 

<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212676747-a0e00ede-19af-4383-8bb6-2ece83a676bc.png">
</p>
<span style = "font-size: 80%">Coloring으로 Node Classification & Graph Classification Task 해결</span>

<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212676770-9b550e49-3a87-43dc-b983-d0e23b22a265.png">
</p>  
<span style = "font-size: 80%">Coloring으로 Link Prediction Task 해결</span>

Link Prediction을 잠시 살펴보면, Link Prediction에서는 노드쌍을 분류하는 것이 목표이고 $$v_0$$를 coloring한 후 GNN 아키텍쳐를 통해 임베딩한다. 이 때, $$v_0$$에 대한 일종의
Constraint가 생긴 것이므로 $$v_1$$과 $$v_2$$에 대해 서로 다른 임베딩 결과가 나오게 된다.

Coloring을 이용하면 자연스럽게 노드들은 두 가지로 **카테로리화**된다.
- Coloring Node
- Non-coloring Node

### 2) Method of Coloring 1

<p align="center">
<img width="100%" alt="1" src="https://user-images.githubusercontent.com/111734605/212679122-79382725-c474-4964-b4d8-fa12e722fbe4.png">
</p>  

Coloring을 하는데 핵심은 바로 <span style = "color:aqua">**Heterogenous Message Passing**</span>이다. 기존의 GNN은 Message computation과 aggregation을 하나의 Neural network를 통해서 진행한다. 즉 같은 방법을 모든 노드에 똑같이 적용하기에 Isomorphic에 취약하다. 위의 왼쪽 그림을 보면 하나의 Neural network를 이용해 모든 노드에 Message passing을
진행하는 것을 볼 수 있다. 

반면 오른쪽 그림을 보면, <span style = "color:gold">**서로 다른 Neural network가 서로 다른 노드**들에 대하여 Message Passing을 진행</span>한다. 이렇게 되면 Neural network에 따라 노드들이 카테고리화된다. 이것이 Coloring이다.

**Heterogenous**라는 것은 결국 다른 타입의 메세지 패싱이 다른 노드들에 적용되는 것이다.  

### 3) Method of Coloring 2
<span style = "font-size:110%">**Inductive identity coloring**</span>  

주어진 노드$$v \in \cal G$$를 K-layer ID-GNN을 통해 임베딩하려면 먼저 K-hop ego network $$\cal G_v^{(K)}$$를 먼저 추출하고, ego network의 중심 노드를 coloring한다.  
ego network로 인해 임베딩 과정에서 두 가지 타입으로 Categorized 된다. 
- Categorized
  - Nodes with coloring
  - Nodes without coloring

이 coloring technicque를 *Inductive*라 한다. 그 이유는, 비록 배열되어 있더라고 **ego network의 중심 노드에 따라 이웃 노드들이 변할 수 있기 때문**이다.

<span style = "font-size:110%">**Heterogenous message passing**</span>  

총 K 번의 라운드(Iteration) Message Passing은 추출된 모든 ego network에 적용된다. $$h_v^{(K)}$$는 K라운드 적용된 뒤에 노드 $$v$$의 Embedding Representation(노드 임베딩의 결과)이다. 그 식은 다음과 같다.

<p align="center">
<img width="800" alt="1" src="https://user-images.githubusercontent.com/111734605/212696275-56cafab7-0302-49d0-8cec-7f0ec7b42469.png">
</p>  

ID-GNN의 Message Passing은 오른쪽 식이다. 이 식의 기본꼴은 왼쪽 식인 기존의 GNN과 동일하다. 여기서 다른 것은 Indicator function $$\mathbb{1}[s=v]$$ 이다. 앞서 말했듯, Coloring으로 인해 ID-GNN에서는 노드들이 두 가지로 **Categorization**되어있다.
- Indicator function $$s = v$$
  - s = v = 1
    - nodes with identity coloring
  - s = v = 0
    - nodes without identity coloring

따라서, <span style = color:gold>Message passing이 Coloring된 노드들과 Coloring되지 않은 노드들이 따로 되는 것</span>이다.  
(그림에서처럼 Message Passing에 **다른 Neural Network**를 이용)

## 4. Experiment & Result
## 5. Contribution
## Reference
