---
title: "[논문리뷰]AttnComp: Leveraging Attention to Effectively Compress Prompts for Long-Context LLMs(AAAI, 2025)"

categories: 
  - NR
  
toc: true
toc_sticky: true

date: 2025-11-03
last_modified_at: 2025-11-03
---

*Yunlong Zhao, Haoran Wu, and Bo Xu*. 2025. [**Leveraging Attention to Effectively Compress Prompts for Long-Context LLMs**](https://ojs.aaai.org/index.php/AAAI/article/view/34800). Proceedings of the AAAI Conference on Artificial Intelligence 39, 24 (Apr. 2025), 26048–26056. https://doi.org/10.1609/aaai.v39i24.34800

# Problem Statement
이 논문은 Long-context 환경에서 LLM의 효율적인 추론을 위해 입력으로 들어오는 프롬프트의 불필요한 부분을 제거하면서도 모델 성능을 최대한 보존하는 Prompt Compression 방법을 개발하는 것이다. 기존 연구는 주로 정보 엔트로피(PPL 기반)에 의존하거나 토큰을 제거하는 과정에서 각각의 토큰을 독립적으로 처리해 전체적의 의미를 회순하는 문제가 있음을 지적한다.

**이전 연구들의 한계점**  
- **[경험적 지표 PPL 의존의 한계]** 정보 엔트로피(PPL)는 **자연어의 중복을 가정한 경험적 지표**로, **문맥 중요도를 최적으로 반영하지 못하는 경우가 많다**. 특히 미세한 질의-문맥 연관성이나 토큰 간 상호작용을 충분히 포착하지 못한다.
- **[독립성 가정의 한계]** 토큰을 **독립적으로** 유지/제거 판단하는 절차는 남은 프롬프트의 **총체적 의미 훼손**을 초래할 수 있으며, 실제로 토큰들은 강한 의존성을 가진 의미 단위(구/절/문)로 작동한다.

**Research Question**  
- **Q1:** 문맥 내 정보 중요도를 더 잘 측정하는 지표는 무엇인가?
- **Q2:** 압축 시 독립성 가정을 깨고, 함께 고려되어야 할 토큰 묶음(의미 단위)를 어떻게 찾아 제거/보존할 것인가?

<br/>
<br/>

# 2. Methodology
## 2.1. Overview
<p align="center">
<img width="1000" alt="1" src="https://github.com/meaningful96/Blogging/blob/main/Paper_Review/%5B2025.11.02%5DAttnComp/AttnComp_figure1.png?raw=true">
</p>

AttnComp는 (i) 질의-문맥 간 <span style="color:gold">**인과적 교차 어텐션(Query-guided Cross-Attention, CA)로 토큰 중요도를 산출**</span>하여 미세 압축 지표로 사용하고, (ii) 문서 내부 자기어텐션(Self-Attention, SA)로 토큰 그래프를 구성해 <span style="color:gold">**최대 스패닝 트리(Maximum, Spanning Tree, MST)와 Louvain 커뮤니티 탐지를 이용해 토큰을 의미 단위로 군집화한 뒤 단위 수준에서 필터링**</span>하는 그래프 기반 압축을 수행한다. 이 알고리즘을 한 번의 LLM 호출로 동작하기 때문에 지연시간(latency)가 낮다.

<center>$$\min_{\tilde{x}} \text{D} \big(LLM(\tilde y \mid \tilde x), LLM(y \mid x) \big)$$</center>

프롬프트 압축(Prompt Compression)에 대한 목적 함수를 수식으로 정의하면 위와 같다. 여기서 $$x, y$$는 각각 압축 전의 입력 프롬프트와 이를 기반으로 LLM이 생성한 컨텍스트이고, $$\tilde x, \tilde y$$는 압축 후의 LLM의 입·출력을 의미한다. $$\text{D}$$는 확률분포의 거리(distance)이다. 

## 2.2. Attention Extraction
- **입력:** $$x = (x_{\text{document}}, x_{\text{query}})$$
- **출력: CA, SA**

LLM의 causal attention 특성상, 미래 토큰은 보지 못하므로, 질의를 문서 뒤에 배치하여 질의 토큰이 문서 정보에 접근하도록 구성한다. 

<center>$$\textbf{Attn} = \text{CausalLM}(x_{doc}, x_{query}), \quad \textbf{CA} =\textbf{Attn}_{1:c, n},\;\;  \textbf{SA} =\textbf{Attn}_{1:c, 1:c}$$</center>

- $$c$$: 문서 길이
- $$n$$: 전체 프롬프트 길이 (문서 + 질의)

**CA**는 “질의의 마지막 토큰 → 문서 토큰”의 어텐션이고, **SA**는 문서 토큰 간 어텐션 행렬이다.

## 2.3. Cross-Attention as the Compression Metric (Solution of Q1)
기존의 PPL기반 정보 엔트로피 대신 <span style="color:gold">**retrieval heads의 어텐션 분포가 반영된 CA를 중요도 지표로 사용**</span>하면, 질의-문맥 간 세밀한 연관성을 더 잘 포착할 것이라는 가정한다. **서로 패턴이 다른 다중 head의 분포중 max값을 집계하여, 질의가 문서의 어떤 토큰에 강하게 도달하는지를 지표화**한다.

**중요도(importance) 정의**  
<center>$$\text{score}(t) =\max_{h \in H}\{ \textbf{CA}_t^h \}$$</center>

상위 $$H$$개 retrieval heads를 선별한 뒤 max값으로 aggregation을 한다. 이후 백분위 필터링(e.g., `np.percentail`)로 하위 $$p$$% 토큰은 제거하여 목표 압축비를 맞춘다.

## 2.4. Semantic Unit Identification with Self-Attention (Solution of Q2)
독립성 가정을 깨기 위해 토큰을 독립적으로 활용하는 것이 아닌, <span style="color:gold">**의미 단위로 묶어 단위 수준에서 보존/제거를 결정하기위해 자기어텐션(self-attention)을 사용**</span>한다.

<center>$$\max_{\{U_i\}} \displaystyle\sum_{i=1}^k A_{\text{intra}}(U_i) - \lambda \displaystyle\sum_{1\leq i < j \leq k} A_{\text{inter}}(U_i, U_j)$$</center>

이를 위한 목적 함수는 위와 같다. 이 때, $$U_i, U_j$$는 토큰을 의미 단위로 묶은 unit이고, $$A_{\text{intra}}$$는 unit 내부 SA 합, $$A_{\text{inter}}$$는 unit 간 SA합이다. 이를 최적화 함으로써 <span style="color:gold">**unit 내부는 아주 강하고, unit간 연결은 희박한 구조를 최대로 만든다**</span>. 하지만 이 목적 함수를 계산하는 것은 매우 큰 cost를 요구한다. 따라서, cost를 최소화하기 위해 **MST(Maximum Spanning Tree, 최대 스패닝 트리)**와 **Louvain 커뮤니티 탐지(Communitiy Detection)**를 사용해 근사한다.

**Step 1. MST로 핵심 연결만 보존**  
문서 길이를 $$c$$라고 할 때, 자기어텐션 SA는 $$\textbf{Attn}_{1:c, 1:c}$$이다. 임의의 토큰 쌍 ($$i, j$$)에 대해

<center>$$w(i, j) =\max_{h \in H} \textbf{SA}^h[i,j]$$</center>

를 **가중치(weight)**로 사용하여 완전 그래프를 구성한다.

**Step2. MST(Maximum Spanning Tree) 추출**  
<center>$$T = \text{FindMST}(G)$$</center>

**MST**는 **그래프에서 가장 강한 연결(=높은 어텐션)을 유지**하고, 상대적으로 약한 연결을 자동으로 제거한다. Spanning Tree (신장 트리)는 모든 정점을 연결하되 불필요한 간선은 제거한 최소 연결 구조를 가지는 그래프이다. 이 때, 가중치 합을 최소 혹은 최대로 하느냐에 다음과 같은 특징을 가지게 된다.
- **Minimum Spanning Tree**
    - 여러 Spanning Tree 중에서 **간선 가중치 합이 최소**가 되는 트리, **비용 최소화**
    - e.g., 도시들을 도로로 연결할 때, 총 도로 길이가 최소가 되도록 하는 경우
- **Maximum Spanning Tree**
    - 여러 Spanning Tree 중에서 **간선 가중치 합이 최대**가 되는 트리, **이익 최대화**
    - 즉 가능한 “큰 가중치의 간선”을 우선적으로 선택해서 만든 트리

MST를 통해 "<span style="color:gold">**단위(unit) 내부 결속력 극대화**</span>"와 "<span style="color:gold">**단위 간 결속력 최소화**</span>"를 자연스럽게 충족시킨다.

**Step 3. Louvain Algorithm: 의미 단위(unit) 도출**  
<center>$$U_1, \cdots, U_K = \text{Louvain}(T)$$</center>

MST 위에서 Louvain 커뮤니티 탐지 알고리즘을 적용한다. 커뮤니티 탐지의 본질은 다음과 같다.

- 단위 내부 결속(intra)는 높임 (↑)
- 단위 외부 결속(inter)은 낮춤 (↓)

이러한 모듈러리티를 최적화하는 방식이므로, 그 자체로 목적 함수를 최적화하는 것과 동일해진다. 결과적으로 토큰들은 "<span style="color:gold">**구·절·문 단위의 자연스러운 의미 블록**</span>"으로 묶인다.

**Step 4. 단위 중요도 계산**  
의미 단위별 중요도는 내부 토큰들이 갖는 교차어텐션(CA) 기반 Score의 평균

<center>$$S(U_k) = \frac{1}{\vert U_k \vert} \displaystyle\sum_{t_i \in U_k}\text{score}(i)$$</center>

CA score는 질의와 가장 강하게 연결된 토큰을 반영한다. 최종적으로 의미 단위 기반 압축은 단위 중요도값을 $$S(U_k)$$ 값을 기준으로 하위 백분위 $$p$$%의 단위 전체를 제거하고, 남은 단위를 원래 순서대로 이어 붙여 최종 압축 문서를 생성한다.

### AttnComp 알고리즘
<p align="center">
<img width="500" alt="1" src="https://github.com/meaningful96/Blogging/blob/main/Paper_Review/%5B2025.11.02%5DAttnComp/AttnComp_figure2.png?raw=true">
</p>

전체 AttnComp 알고리즘은 **CA 기반 토큰 중요도 산출**, **SA 기반 의미 단위 탐지**, **단위 중요도 기반 필터링**, **압축 문서 생성**의 4단계로 구성된다. 이 과정은 단 **한 번의 LLM forward pass**만 필요하므로 기존 반복 압축 방식보다 지연시간이 짧으며 안정적이다.

중요한 점은 MST→Louvain 단계는 “어떤 커뮤니티를 고르느냐”가 아니라 "<span style="color:gold">**각 커뮤니티에 점수를 매겨 하위 p%를 버리고 나머지 커뮤니티의 토큰을 보존하느냐**</span>"의 문제이며, 선택 기준은 질의가 문맥 토큰에 주는 **크로스어텐션 기반 중요도**를 커뮤니티 수준으로 집계한 점수이다. 의미 단위(unit) 토큰 집합 $$[U_1, \cdots, U_k]$$가 Louvain 알고리즘으로 생성된 각각의 커뮤니티이다.

<br/>
<br/>

# Experiments
## 3.1. Main Results
<p align="center">
<img width="1000" alt="1" src="https://github.com/meaningful96/Blogging/blob/main/Paper_Review/%5B2025.11.02%5DAttnComp/AttnComp_figure3.png?raw=true">
</p>

Table 1은 NQ에서 **GPT-3.5-Turbo**와 **LongChat-13B**를 대상으로, 문서 포지션(1st~20th) 및 Reorder 전략 하에 정확도(Acc)를 비교하고, 동시에 압축 후 입력 길이(Tokens)와 압축배율(1/τ)을 제시한다. 여기서 문서 포지션은 어떤 question에 대해서 retrieval을 했을 때 정답문서가 1, 5, 10, 15, 20번째에 위치한 case를 의미한다. 즉 문서 포지션이 5라는 것은 리트리브 결과 정답 문서가 5번째에 존재한 질의 샘플들이다. Reorder는 모든 질문들에 대해서 정답 문서를 첫번째 순서에 배치하는 경우이다. † 표시는 coarse-grained(Cond.PPL)을 함께 쓴 구성임을 뜻한다. 

AttnComp은 두 모델 모두에서 **가장 높은 Acc**와 가장 큰 압축배율(짧은 입력 길이)을 동시에 달성한였다. 특히 기존 SOTA 모델인 LongLLMLingua의 평균 토큰 압축률은 3.9배 정도로 평균 2,946 토큰으로 구성된 프롬프트가 평균 748토큰으로 압축되는 반면, AttnComp는 평균 647 토큰으로 압축되었다. 이는 3.9배 보다 큰 4.5배 정도이다. 그럼에도 불구하고 성능 측면에서는 모든 케이스에 항상 더 높은 성능을 달성하였다. 특히 정답 문서가 20개의 문서 중 중간에 위치한 경우 발생하는 Lost-in-the-middle 문제도 어느 정도 완화되었다.

## 3.2. Ablation study
<p align="center">
<img width="500" alt="1" src="https://github.com/meaningful96/Blogging/blob/main/Paper_Review/%5B2025.11.02%5DAttnComp/AttnComp_figure4.png?raw=true">
</p>

**Table 2**
- **의미 단위 제거(w/o Semantic Units),**
- 구 단위(Phrase) 대체,
- **retrieval heads 미사용 (w/o Retrieval Heads),**
- PPL 지표 대체,
- Iterative 토큰 압축 등 변형

Table 2는 AttnComp의 ablation study 결과를 보여준다. <span style="color:gold">**Semantic Units(SA기반 MST + Louvain)을 제거**</span>하면 단위 별로 토큰을 묶은 것이 아닌, <span style="color:gold">**"토큰 독립성 가정 상태"로 돌아가며 성능이 가장 크게 하락**</span>한다. 이는 토큰을 개별적으로 제거하면 의미 흐름이 붕괴한다는 것을 의미한다. 이는 토큰을 특정 단위(unit)로 압축해야 문장의 논리 구조가 유지되는데 토큰 단위로 압축하면 문장의 구문이 깨지기 때문이다.

하지만 규칙 기반의 Phrase (w/ Phrase)로 대체할 경우에는 성능이 떨어지는 것을 볼 수 있다. 이 규칙 기반의 구문은 문장을 단순하게 슬라이싱 단위로 조각 내어 겉으로 보이는 묶음이지, LLM이 실질적으로 중요하게 여기는 구문이 아님을 시사한다. 즉, **토큰 단위로 독립적으로 다루는 것보다는 좋지만, n그램처럼 규칙 기반의 단위는 LLM이 실질적으로 원하지 않는 구문**이라는 것을 말해준다.

또한 중요한 head만을 사용하는 것이 아닌, 전체 head를 사용하여 (mean pooling aggregation)을 사용하면 성능이 떨어지는 것을 볼 수 있다. 이는 **모든 head의 정보가 오히려 노이즈로 작용**한다는 것을 의미한다.

## 3.3. Analysis
<p align="center">
<img width="500" alt="1" src="https://github.com/meaningful96/Blogging/blob/main/Paper_Review/%5B2025.11.02%5DAttnComp/AttnComp_figure5.png?raw=true">
</p>

Figure 2는 필터링 비율(10%–60%) 변화에 따라 AttnComp의 교차주의(CA) 기반 토큰 중요도(score)가 기존의 PPL(entropy 기반) 및 ITPC(LLMLingua score) 대비 얼마나 강건한지를 비교한 것이다. 실험 결과, CA 기반 지표는 고압축(high-compression) 영역에서도 원 성능의 90% 이상을 유지하는 반면, PPL과 ITPC는 필터링 비율이 증가할수록 성능이 급격하게 붕괴되는 양상을 보인다. 이는 <span style="color:gold">**CA가 질의–문맥 간 실제 정보 의존 경로를 더 정확히 포착함**</span>을 직접적으로 증명하는 결과이다.

CA 기반 중요도는 전체 구간에서 점진적이고 완만한 감소 곡선을 형성하며, 특히 50–60% 이상의 고압축 수준에서도 원본 대비 약 90% 이상의 정확도를 유지한다는 점이 특징이다. 반면 PPL 및 ITPC는 20–30% 수준부터 급격히 하락하기 시작하며, 50–60% 구간에서는 원 성능의 절반 이하까지 떨어지는 경우가 발생한다. 이러한 차이는 지표들이 무엇을 측정하는지에서 비롯된다. PPL/ITPC는 언어적 예측 난이도나 문법적 구조에 기반한 휴리스틱이지만, CA는 "<span style="color:gold">**질의의 마지막 토큰이 각 문서 토큰에 얼마나 강하게 의존하는지**</span>"를 LLM 내부에서 직접 읽어내므로 <span style="color:gold">**정답에 필요한 토큰을 선택적으로 유지하는 능력이 압도적으로 높다</span>.

## 3.4. Latency Analysis
<p align="center">
<img width="500" alt="1" src="https://github.com/meaningful96/Blogging/blob/main/Paper_Review/%5B2025.11.02%5DAttnComp/AttnComp_figure6.png?raw=true">
</p>

Table 5는 압축 과정까지 포함한 총 지연시간(Compression + LLM 응답)을 비교해 AttnComp이 기존 반복 압축 방식(LongLLMLingua 등) 대비 얼마나 효율적인지를 평가한다. 결과적으로 AttnComp은 <span style="color:gold">**동일 압축률에서 더 짧은 지연시간을 달성**</span>하며, 심지어 더 높은 압축률(예: 9.4×)에서도 경쟁력 있는 정확도와 낮은 지연시간을 동시에 확보한다는 점이 확인된다(표 5). 다만 매우 긴 프롬프트에서는 의미 단위 탐지(SA 기반 그래프 구축)의 연산 비용이 상대적으로 증가할 수 있어, 이 부분은 향후 최적화 가능성이 있다.

<br/>
<br/>

# 4. Conclusion
AttnComp은 **SA(Self-Attention)를 통한 의미 단위 생성**과 **CA(Cross-Attention)를 통한 정보 중심 토큰 중요도 계산**을 결합하여, 기존 반복 기반 압축 기법보다 **더 짧고, 더 정확하며, 더 빠른** 프롬프트 압축을 달성하는 방법이다. NQ, LongBench 등 다양한 장문 이해·추론 태스크에서 실험을 통해 설계의 타당성과 효율성이 검증되었다.

**Limitations**  
- **[SA 단위 탐지의 연산 비용 증가]** 입력이 매우 길어질 경우 SA 기반 그래프 구축과 단위 탐지 과정의 연산 비용이 상대적으로 증가한다.
- **[모델 구조 의존성]** CA score 계산 시 사용되는 retrieval head 선택이 모델 구조·head 역할 배치에 따라 영향을 받는다.
- **[초고압축 영역의 성능 하락]** 필터링 비율이 지나치게 높아지면 고압축의 구조적 한계로 인해 성능 하락이 불가피하다.
- **[멀티-홉 의존성 반영의 한계]** CA score가 단일 경로 의존성 중심이므로 복잡한 multi-hop reasoning 패턴을 충분히 포착하지 못할 수 있다.

**Contribution**  
- **[CA 기반 질의–문맥 연관성 활용]** 질의와 직접적으로 관련된 토큰만 선택적으로 보존하는 cross-attention 기반 relevance score를 제안하였다.
- **[SA 기반 의미 단위 구축]** self-attention 구조를 활용하여 내부 응집력은 높고 단위 간 연결성은 낮은 semantic units를 자동으로 구성하는 방법을 제안하였다.
- **[단일 패스 기반 압축 수행]** 반복 압축 없이 단일 forward-pass로 효율적으로 프롬프트를 압축하는 구조를 제안하였다.
- **[RAG·장문 이해 전반에서 성능 향상]** NaturalQuestions와 LongBench 등 다양한 장문 QA/추론 태스크에서 높은 압축률과 성능 보존을 동시에 달성하였다.
- **[정보 중심 + 구조 중심의 이중 보존 전략]** CA(정보)와 SA(구조)를 결합한 의미 보존 압축이라는 새로운 category를 창출하였다.
